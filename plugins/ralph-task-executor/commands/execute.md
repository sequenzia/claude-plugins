---
description: Start automated execution of tasks from a spec-task-manager JSON file
argument-hint: <tasks-file> [--parallel] [--auto-sync] [--max-iterations N]
allowed-tools: [Read, Write, Glob, Bash, TodoWrite]
allowed-paths: [".claude/ralph-task-executor.state.json"]
model: inherit
---

# Execute Task File

Start automated execution of tasks from a spec-task-manager `.tasks.json` file using ralph-loop for iterative task completion.

## Arguments

- `$1` (required): Path to the `.tasks.json` file generated by spec-task-manager
- `--parallel`: Enable parallel execution of tasks within the same phase (default: sequential)
- `--auto-sync`: Automatically update task status in the JSON file on completion (default: manual)
- `--max-iterations N`: Maximum ralph-loop iterations per task (default: 10)

## Process

### 1. Parse and Validate Arguments

Parse the command arguments:

```
TASK_FILE = $1 (required)
PARALLEL_MODE = --parallel flag present (default: false)
AUTO_SYNC = --auto-sync flag present (default: false)
MAX_ITERATIONS = --max-iterations value (default: 10)
```

Validate:
- Task file path is provided
- Task file exists and is valid JSON
- Max iterations is between 1 and 100

### 2. Load and Validate Task File

Read the task file and validate structure:
- Must have `metadata` object with `source_document` and `total_tasks`
- Must have `tasks` array with at least one task
- Each task must have `id`, `title`, `description`, `status`, `dependencies`

### 3. Check for Existing Execution State

Check if `.claude/ralph-task-executor.state.json` exists:
- If exists with status "running" or "paused": Warn user and offer to resume or abort
- If exists with status "completed" or "aborted": Offer to start fresh or review

### 4. Initialize Execution State

Create new execution state at `.claude/ralph-task-executor.state.json`:

```json
{
  "version": "1.0.0",
  "status": "running",
  "task_file": "<path-to-tasks-file>",
  "config": {
    "parallel_mode": <PARALLEL_MODE>,
    "auto_sync": <AUTO_SYNC>,
    "max_iterations": <MAX_ITERATIONS>
  },
  "started_at": "<current-ISO-timestamp>",
  "last_activity": "<current-ISO-timestamp>",
  "current_task": null,
  "current_iteration": 0,
  "task_start_time": null,
  "in_progress": [],
  "completed": [],
  "blocked": [],
  "pending_completions": [],
  "task_timings": {},
  "task_artifacts": {},
  "blocked_reasons": {},
  "parallel_batch": null,
  "parallel_pending": 0,
  "metrics": {
    "total_iterations": 0,
    "avg_iterations_per_task": 0,
    "total_time_seconds": 0,
    "avg_time_per_task_seconds": 0
  }
}
```

### 5. Select First Task(s)

Use the task selection algorithm:

1. Filter tasks where:
   - `status` is `not_started`
   - All `dependencies.hard` tasks have status `complete`
   - Not in execution state's `blocked` list

2. Sort by:
   - Priority: critical > high > medium > low
   - Execution phase: lower phase first
   - Complexity: XS > S > M > L > XL (simpler first)

3. Select:
   - Sequential mode: Return first task
   - Parallel mode: Return all tasks in same execution phase as first task

### 6. Build Task Prompt

For each selected task, build the ralph-loop prompt using the template from `skills/task-execution/references/prompt-templates.md`:

1. Start with base template
2. Replace variables: TASK_ID, TITLE, DESCRIPTION
3. Build dependency context from completed hard dependencies
4. Format acceptance criteria, test scenarios, edge cases as bullet lists
5. Set completion promise: `TASK-{ID}-COMPLETE`

### 7. Start Ralph-Loop Execution

For sequential mode (single task):

```
Update execution state:
- current_task = task.id
- in_progress = [task.id]
- task_start_time = now()
- last_activity = now()

Invoke ralph-loop:
/ralph-loop "<generated-prompt>" --max-iterations {MAX_ITERATIONS} --completion-promise "TASK-{ID}-COMPLETE"
```

For parallel mode (multiple tasks):

```
Update execution state:
- parallel_batch = [task1.id, task2.id, ...]
- parallel_pending = batch.length
- in_progress = [task1.id, task2.id, ...]
- last_activity = now()

Note: Parallel execution requires multiple concurrent sessions
Report: "Starting parallel execution of N tasks in phase P"
Start first task via ralph-loop
```

### 8. Monitor and Continue

After each task completes (detected by ralph-loop exit):

1. Check if completion promise was output
2. If successful:
   - Mark task complete in execution state
   - If auto-sync: Update task file status to "complete"
   - Else: Add to pending_completions
   - Record timing metrics
   - Select and start next task(s)

3. If failed (no promise, max iterations reached):
   - Mark task blocked in execution state
   - Record reason: "Max iterations ({N}) reached without completion"
   - Cascade: Mark tasks depending on this one as transitively blocked
   - Select and start next available task(s)

4. If no more tasks available:
   - Check if all tasks complete or blocked
   - Update execution state status to "completed"
   - Report final summary

## Output

Display execution start summary:

```
## Starting Task Execution

**Task File:** {task_file}
**Total Tasks:** {total}
**Already Complete:** {complete_count}
**Blocked:** {blocked_count}
**Ready to Execute:** {ready_count}

**Configuration:**
- Mode: {Sequential|Parallel}
- Auto-sync: {Yes|No}
- Max iterations per task: {N}

**Starting with:** {TASK-ID}: {title}

Use `/ralph-task-executor:exec-status` to check progress.
Use `/ralph-task-executor:pause` to pause execution.
```

## Error Handling

- **Task file not found:** Report error, suggest running spec-task-manager:analyze first
- **Invalid JSON:** Report parsing error with details
- **No executable tasks:** Report all tasks are complete, blocked, or have unmet dependencies
- **Ralph-loop not available:** Report dependency error, suggest installing ralph-loop plugin

## Example Usage

```bash
# Basic sequential execution
/ralph-task-executor:execute tasks/my-feature.tasks.json

# Parallel execution with auto-sync
/ralph-task-executor:execute tasks/my-feature.tasks.json --parallel --auto-sync

# Custom iteration limit
/ralph-task-executor:execute tasks/my-feature.tasks.json --max-iterations 20
```
